<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Realtime JA→EN Translation</title>
  <style>
    /* ========== 全体レイアウト ========== */
    html, body {
      height: 100%;
      margin: 0;
      background: #121212;
      color: #eaeaea;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans JP", sans-serif;
    }
    .wrap {
      display: flex;
      flex-direction: column;
      height: 100%;
    }

    /* ========== ヘッダー（コントロールエリア） ========== */
    header {
      padding: 12px 16px;
      display: flex;
      gap: 12px;
      align-items: center;
      border-bottom: 1px solid #2a2a2a;
      flex-wrap: wrap;
      background: #1a1a1a;
    }
    header button {
      background: #2d6cdf;
      color: #fff;
      border: none;
      padding: 10px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      transition: background 0.2s ease;
    }
    header button:hover {
      background: #2558b8;
    }
    header button.secondary {
      background: #444;
    }
    header button.secondary:hover {
      background: #555;
    }
    header button.danger {
      background: #c53030;
    }
    header button.danger:hover {
      background: #9b2c2c;
    }
    /* 録音中のスタートボタンのスタイル */
    header button#startBtn.recording {
      background: #e53e3e;
      animation: pulse 1.5s ease-in-out infinite;
      box-shadow: 0 0 10px rgba(229, 62, 62, 0.5);
    }
    @keyframes pulse {
      0%, 100% {
        opacity: 1;
        box-shadow: 0 0 10px rgba(229, 62, 62, 0.5);
      }
      50% {
        opacity: 0.8;
        box-shadow: 0 0 20px rgba(229, 62, 62, 0.8);
      }
    }
    header select {
      padding: 8px 12px;
      border-radius: 6px;
      border: 1px solid #333;
      background: #1b1b1b;
      color: #eee;
      font-size: 14px;
    }
    header select:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      background: #0f0f0f;
    }
    #status {
      flex: 1;
      min-width: 150px;
      font-size: 13px;
      color: #aaa;
      font-weight: 500;
    }
    #status.recording {
      color: #fc8181;
      font-weight: 600;
    }

    /* ========== メインエリア（翻訳結果表示） ========== */
    main {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      position: relative;
    }

    #translation-output {
      flex: 1;
      padding: 24px;
      overflow-y: auto;
      line-height: 1.8;
      white-space: pre-wrap;
      word-wrap: break-word;
      scroll-behavior: smooth;
    }

    /* 文字サイズのクラス */
    #translation-output.size-small { font-size: 18px; }
    #translation-output.size-medium { font-size: 28px; }
    #translation-output.size-large { font-size: 42px; }
    #translation-output.size-xlarge { font-size: 56px; }

    /* プレースホルダー表示 */
    #translation-output:empty::before {
      content: "English translation will appear here...";
      color: #555;
      font-style: italic;
    }

    /* ========== フッター ========== */
    footer {
      padding: 8px 16px;
      font-size: 12px;
      color: #777;
      border-top: 1px solid #2a2a2a;
      background: #1a1a1a;
      text-align: center;
    }

    /* ========== スクロールバーのスタイル（Webkit系ブラウザ） ========== */
    #translation-output::-webkit-scrollbar {
      width: 10px;
    }
    #translation-output::-webkit-scrollbar-track {
      background: #1a1a1a;
    }
    #translation-output::-webkit-scrollbar-thumb {
      background: #444;
      border-radius: 5px;
    }
    #translation-output::-webkit-scrollbar-thumb:hover {
      background: #555;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <!-- 録音開始/停止ボタン -->
      <button id="startBtn" onclick="toggleRecording()">Start Recording</button>

      <!-- クリアボタン -->
      <button class="danger" onclick="clearTranslation()">Clear</button>

      <!-- 翻訳頻度選択 -->
      <label for="segmentInterval" style="color: #aaa; font-size: 13px;">Interval:</label>
      <select id="segmentInterval">
        <option value="5000">5 sec</option>
        <option value="10000">10 sec</option>
        <option value="15000" selected>15 sec</option>
        <option value="20000">20 sec</option>
      </select>

      <!-- 文字サイズ選択 -->
      <label for="fontSize" style="color: #aaa; font-size: 13px;">Font Size:</label>
      <select id="fontSize" onchange="changeFontSize()">
        <option value="small">Small (18px)</option>
        <option value="medium" selected>Medium (28px)</option>
        <option value="large">Large (42px)</option>
        <option value="xlarge">X-Large (56px)</option>
      </select>

      <!-- ステータス表示 -->
      <span id="status">Ready</span>
    </header>

    <main>
      <!-- 翻訳結果表示エリア -->
      <div id="translation-output" class="size-medium"></div>
    </main>

    <footer>
      Real-time Japanese → English Translation | WebSocket connected to localhost:8000
    </footer>
  </div>

  <script>
    // ========== グローバル変数 ==========
    let mediaRecorder = null;
    let ws = null;
    let isRecording = false;
    let mime = '';

    // WebSocket URL
    function getWsUrl() {
      return 'ws://localhost:8000/ws';
    }

    // ========== MediaRecorderのサポートするMIMEタイプを選択 ==========
    function chooseMimeType() {
      const candidates = [
        'audio/webm;codecs=opus',
        'audio/webm',
        'audio/ogg;codecs=opus',
        'audio/ogg',
        'audio/wav'
      ];
      for (const c of candidates) {
        if (MediaRecorder.isTypeSupported(c)) return c;
      }
      return '';
    }

    // ========== 録音開始/停止トグル ==========
    async function toggleRecording() {
      if (isRecording) {
        stopRecording();
      } else {
        await startRecording();
      }
    }

    // ========== 録音開始 ==========
    async function startRecording() {
      if (isRecording) return;

      try {
        // 1) WebSocket接続
        const url = getWsUrl();
        ws = new WebSocket(url);
        ws.binaryType = 'arraybuffer';

        ws.onopen = () => {
          // console.log('WebSocket connected:', url);
          updateStatus('WebSocket connected');
          // サーバ側のバッファをリセット
          try { ws.send('reset'); } catch {}
        };

        ws.onclose = () => {
          // console.log('WebSocket closed');
          updateStatus('WebSocket closed');
        };

        ws.onerror = (e) => {
          // console.error('WebSocket error', e);
          updateStatus('WebSocket error');
        };

        ws.onmessage = (ev) => {
          try {
            const data = JSON.parse(ev.data);
            // console.log('[DEBUG] Received WebSocket message:', data);
            if (data.status === "processing") {
              // Ignore processing status messages (keepalive)
              // console.log('[DEBUG] Processing status received');
              return;
            } else if (data.english !== undefined) {
              // console.log('[DEBUG] English translation received:', data.english);
              appendTranslation('', data.english);
            } else if (data.error) {
              console.error('Server error:', data.error);
              updateStatus('Error: ' + data.error);
            }
          } catch (err) {
            // console.warn('Non-JSON message:', ev.data);
          }
        };

        // 2) マイク取得
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        mime = chooseMimeType();
        mediaRecorder = new MediaRecorder(stream, mime ? { mimeType: mime } : undefined);

        // サーバへMIMEヒントを送る
        try {
          if (ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ mime }));
          }
        } catch {}

        // 3) MediaRecorderのデータ送信
        // onstop時に完全なWebMファイルを送信する方式に変更
        let recordingTimeout = null;

        mediaRecorder.addEventListener('dataavailable', async (ev) => {
          // console.log('[DEBUG] dataavailable event fired, size:', ev.data?.size);
          if (!ev.data || ev.data.size === 0) {
            // console.warn('[DEBUG] Empty audio data, skipping');
            return;
          }
          if (!ws || ws.readyState !== WebSocket.OPEN) {
            // console.warn('[DEBUG] WebSocket not open, state:', ws?.readyState);
            return;
          }
          const buf = await ev.data.arrayBuffer();
          // console.log('[DEBUG] Sending audio chunk, bytes:', buf.byteLength);
          ws.send(buf); // バイナリを /ws へ送信
        });

        // 選択された間隔でデータを区切って送信
        const segmentSelect = document.getElementById('segmentInterval');
        const segmentMs = parseInt(segmentSelect.value);

        // MediaRecorderを自動的に停止/再起動して完全なWebMチャンクを生成
        function scheduleRecordingCycle() {
          if (!isRecording || !mediaRecorder) return;

          window.recordingTimeout = setTimeout(() => {
            if (!isRecording || !mediaRecorder || mediaRecorder.state !== 'recording') return;

            // console.log('[DEBUG] Stopping MediaRecorder to finalize chunk...');
            mediaRecorder.stop();

            // データが送信されるまで少し待ってから再起動
            setTimeout(() => {
              if (!isRecording || !mediaRecorder) return;
              // console.log('[DEBUG] Restarting MediaRecorder...');
              mediaRecorder.start();
              scheduleRecordingCycle();
            }, 100);
          }, segmentMs);
        }

        mediaRecorder.start();
        isRecording = true;
        scheduleRecordingCycle();

        // UIを更新
        const startBtn = document.getElementById('startBtn');
        const statusEl = document.getElementById('status');
        const fontSizeSelect = document.getElementById('fontSize');

        startBtn.textContent = 'Stop Recording';
        startBtn.classList.add('recording');
        statusEl.classList.add('recording');

        // 録音中は設定変更を無効化
        segmentSelect.disabled = true;
        fontSizeSelect.disabled = true;

        updateStatus(`🔴 Recording... (${mime || 'default'}, ${segmentMs / 1000}s chunks)`);

      } catch (error) {
        console.error('Failed to start recording:', error);
        updateStatus('Error: ' + error.message);
        alert('マイクへのアクセスに失敗しました。ブラウザの設定を確認してください。');
      }
    }

    // ========== 録音停止 ==========
    function stopRecording() {
      if (!isRecording) return;

      // タイムアウトをクリア
      if (window.recordingTimeout) {
        clearTimeout(window.recordingTimeout);
        window.recordingTimeout = null;
      }

      try {
        if (mediaRecorder) {
          mediaRecorder.stop();
          // マイクストリームを停止
          mediaRecorder.stream.getTracks().forEach(track => track.stop());
        }
      } catch {}

      mediaRecorder = null;
      isRecording = false;

      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send('stop'); // サーバに終了を通知
        ws.close();
      }
      ws = null;

      // UIを更新
      const startBtn = document.getElementById('startBtn');
      const statusEl = document.getElementById('status');
      const segmentSelect = document.getElementById('segmentInterval');
      const fontSizeSelect = document.getElementById('fontSize');

      startBtn.textContent = 'Start Recording';
      startBtn.classList.remove('recording');
      statusEl.classList.remove('recording');

      // 録音停止時は設定変更を有効化
      segmentSelect.disabled = false;
      fontSizeSelect.disabled = false;

      updateStatus('Stopped');
    }

    // ========== 翻訳結果をリアルタイムで追記 ==========
    function appendTranslation(japaneseText, englishText) {
      const outputEl = document.getElementById('translation-output');

      // 英語テキストのみ使用
      const trimmedText = (englishText || '').trim();

      // 空なら何もしない
      if (!trimmedText) return;

      // 各チャンクを独立して表示（累積なし）
      // 改行ロジック: ピリオド、疑問符、感嘆符の後にスペースがある場合は改行
      const processedText = trimmedText.replace(/([.!?])\s+/g, '$1\n');

      if (outputEl.textContent) {
        // スペースを追加して連結
        outputEl.textContent += ' ' + processedText;
      } else {
        outputEl.textContent = processedText;
      }

      // 自動スクロール
      outputEl.scrollTop = outputEl.scrollHeight;
    }

    // ========== 翻訳結果をクリア ==========
    function clearTranslation() {
      const outputEl = document.getElementById('translation-output');
      outputEl.textContent = '';
      updateStatus('Translation output cleared');
    }

    // ========== 文字サイズ変更 ==========
    function changeFontSize() {
      const outputEl = document.getElementById('translation-output');
      const select = document.getElementById('fontSize');
      const size = select.value;

      // 既存のサイズクラスを削除
      outputEl.classList.remove('size-small', 'size-medium', 'size-large', 'size-xlarge');

      // 新しいサイズクラスを追加
      outputEl.classList.add('size-' + size);
    }

    // ========== ステータス更新 ==========
    function updateStatus(message) {
      const statusEl = document.getElementById('status');
      statusEl.textContent = message;
    }

    // ========== 初期化 ==========
    window.addEventListener('DOMContentLoaded', () => {
      updateStatus('Ready. Click "Start Recording" to begin.');
    });

    // ========== ページ離脱時のクリーンアップ ==========
    window.addEventListener('beforeunload', () => {
      if (isRecording) {
        stopRecording();
      }
    });
  </script>
</body>
</html>
